/// <reference types="@cloudflare/workers-types" />
// Cloudflare Workers (í‘œì¤€ fetch í•¸ë“¤ëŸ¬) â€” Hono ë¯¸ì‚¬ìš©

import type {
  ExecutionContext,
  KVNamespace,
  ScheduledEvent,
} from '@cloudflare/workers-types'
import { createClient } from '@supabase/supabase-js'

export interface Env {
  // CORS
  ALLOWED_ORIGINS?: string
  ALLOWED_ORIGIN_PREFIXES?: string

  // KAMIS
  KAMIS_BASE_URL?: string
  KAMIS_CERT_ID?: string
  KAMIS_CERT_KEY?: string

  // App meta
  API_VERSION?: string
  PREFETCH_KEYS?: string

  // Supabase
  // ê¶Œì¥: SUPABASE_SERVICE_ROLE ì— service_role key ì €ì¥
  // (êµ¬) SUPABASE_SERVICE_KEY ë§Œ ì¡´ì¬í•´ë„ ë™ì‘í•˜ë„ë¡ fallback ìœ ì§€
  SUPABASE_URL?: string
  SUPABASE_SERVICE_ROLE?: string
  SUPABASE_SERVICE_KEY?: string
  SUPABASE_TABLE?: string

  // Admin
  ADMIN_API_TOKEN?: string

  // KV
  FRUIT_CACHE: KVNamespace // /prices ì‘ë‹µ + rate limit ì¹´ìš´í„°
  PRICE_CACHE: KVNamespace // ê·¸ë˜í”„ / dailySales_master ë“± ê°€ê³µ ë°ì´í„°
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê³µí†µ í—¤ë” / ìœ í‹¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const SEC_HEADERS: Record<string, string> = {
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'Referrer-Policy': 'no-referrer',
  'Permissions-Policy':
    'camera=(), microphone=(), geolocation=(), gyroscope=(), magnetometer=(), accelerometer=()',
}

// ë…¼ë¦¬ TTL: 1ì‹œê°„, ë¬¼ë¦¬ TTL: 24ì‹œê°„
const LOGICAL_TTL_MS = 60 * 60 * 1000
const HARD_TTL_SECONDS = 24 * 60 * 60

// âœ… KAMIS ê¸°ë³¸ URL ìœ í‹¸ (http + ëì˜ ? ì œê±°)
function getKamisBase(env: Env): string {
  const raw =
    env.KAMIS_BASE_URL ||
    'http://www.kamis.or.kr/service/price/xml.do' // ê¸°ë³¸ê°’ì€ http
  return raw.replace(/\?+$/, '')
}

function safeJSON<T>(s: string | undefined, fallback: T): T {
  try {
    return s ? (JSON.parse(s) as T) : fallback
  } catch {
    return fallback
  }
}

function getCors(req: Request, env: Env) {
  const origin = req.headers.get('origin') ?? ''
  const exact: string[] = safeJSON(env.ALLOWED_ORIGINS, [])
  const prefixes: string[] = safeJSON(env.ALLOWED_ORIGIN_PREFIXES, [])
  const isAllowed =
    !!origin &&
    (exact.includes(origin) || prefixes.some((p) => origin.startsWith(p)))
  return {
    allowOrigin: isAllowed ? origin : '',
    headers: {
      'Access-Control-Allow-Origin': isAllowed ? origin : '',
      Vary: 'Origin',
    } as Record<string, string>,
  }
}

function json(
  body: unknown,
  cors: Record<string, string>,
  init: ResponseInit = {},
) {
  const headers = {
    ...SEC_HEADERS,
    ...cors,
    'Content-Type': 'application/json; charset=utf-8',
    ...(init.headers || {}),
  }
  return new Response(JSON.stringify(body), { ...init, headers })
}

function getClientIP(req: Request): string {
  return req.headers.get('CF-Connecting-IP') || '0.0.0.0'
}

async function readJSON<T = any>(
  req: Request,
  maxBytes = 512 * 1024,
): Promise<T> {
  const buf = new Uint8Array(await req.arrayBuffer())
  if (buf.byteLength > maxBytes) throw new Error('payload_too_large')
  const txt = new TextDecoder().decode(buf)
  return JSON.parse(txt) as T
}

function withAbortTimeout(ms: number) {
  const ac = new AbortController()
  const t = setTimeout(() => ac.abort('timeout'), ms)
  return { signal: ac.signal, clear: () => clearTimeout(t) }
}

/** í˜„ì¬ KST(UTC+9) ê¸°ì¤€ ì‹œ(hour) */
function getKstHour(): number {
  const now = new Date()
  return (now.getUTCHours() + 9) % 24
}

/** Supabase Admin ìê²© ê³µí†µ ìœ í‹¸ */
function getSupabaseAdminCred(env: Env) {
  const supabaseUrl = env.SUPABASE_URL ?? ''
  const serviceKey = env.SUPABASE_SERVICE_ROLE ?? env.SUPABASE_SERVICE_KEY ?? ''
  return { supabaseUrl, serviceKey }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ê·¸ë˜í”„ ê³µí†µ ìœ í‹¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

interface GraphPoint {
  regday: string
  price: number
}

function gYmd(d: Date): string {
  const y = d.getFullYear()
  const m = String(d.getMonth() + 1).padStart(2, '0')
  const day = String(d.getDate()).padStart(2, '0')
  return `${y}-${m}-${day}`
}

function gDateRangeDays(n: number): { start: string; end: string } {
  const end = new Date()
  const start = new Date(end.getTime())
  start.setDate(start.getDate() - (n - 1))
  return { start: gYmd(start), end: gYmd(end) }
}

function gSplitRanges(
  start: string,
  end: string,
  maxSpan = 120,
): Array<[string, string]> {
  const res: Array<[string, string]> = []
  const sd = new Date(start)
  const ed = new Date(end)
  let curStart = new Date(sd)
  while (curStart <= ed) {
    const curEnd = new Date(curStart)
    curEnd.setDate(curEnd.getDate() + (maxSpan - 1))
    if (curEnd > ed) res.push([gYmd(curStart), gYmd(ed)])
    else res.push([gYmd(curStart), gYmd(curEnd)])
    curStart = new Date(curEnd)
    curStart.setDate(curStart.getDate() + 1)
  }
  return res
}

/** KAMIS ì¸ì¦ íŒŒë¼ë¯¸í„° + action ê³µí†µ ìœ í‹¸ (ì„œë²„ ì¸¡ í˜¸ì¶œìš©) */
function buildKamisParams(env: Env, action: string, extra: Record<string, string>) {
  const sp = new URLSearchParams()
  if (env.KAMIS_CERT_ID) sp.set('p_cert_id', env.KAMIS_CERT_ID)
  if (env.KAMIS_CERT_KEY) sp.set('p_cert_key', env.KAMIS_CERT_KEY)
  sp.set('p_returntype', 'json')
  sp.set('action', action)
  for (const [k, v] of Object.entries(extra)) {
    if (v != null) sp.set(k, v)
  }
  return sp
}

function gDeepCollectRows(node: any, bag: any[] = []): any[] {
  if (node == null) return bag
  if (Array.isArray(node)) {
    for (const x of node) gDeepCollectRows(x, bag)
    return bag
  }
  if (typeof node === 'object') {
    let keys: string[] = []
    try {
      keys = Object.keys(node)
    } catch {
      return bag
    }
    const lower = keys.map((k) => k.toLowerCase())
    const hasReg = lower.some(
      (k) =>
        k === 'regday' ||
        k === 'reg_date' ||
        k === 'date' ||
        k === 'day' ||
        k.includes('regday'),
    )
    const hasPrice = lower.some(
      (k) => k === 'dpr1' || k === 'price' || k === 'value' || k.includes('price'),
    )
    if (hasReg && hasPrice) bag.push(node)

    let values: any[] = []
    try {
      values = Object.values(node)
    } catch {
      return bag
    }
    for (const v of values) gDeepCollectRows(v, bag)
  }
  return bag
}

function gParsePrice(v: any): number | null {
  if (v == null) return null
  const s = String(v).replace(/,/g, '').trim()
  if (!s || s === '-' || s.toUpperCase() === 'NULL') return null
  const n = Number(s)
  return Number.isFinite(n) ? n : null
}

function gPickRegdayField(r: any): string {
  const keys = ['regday', 'reg_date', 'date', 'day', 'REGDAY', 'regDay']
  for (const k of keys) {
    if (r[k]) return String(r[k])
  }
  const yyyy = r.yyyy ?? r.year
  const mm = r.mm ?? r.month
  const dd = r.dd ?? r.day
  if (yyyy && mm && dd) {
    return `${String(yyyy).padStart(4, '0')}-${String(mm).padStart(
      2,
      '0',
    )}-${String(dd).padStart(2, '0')}`
  }
  return ''
}

function gNormalizeRegday(raw: string, start: string, end: string): string | null {
  if (!raw) return null
  let s = String(raw).trim().replace(/\s+/g, '').replace(/\./g, '-').replace(/\//g, '-')
  if (s.includes('0000')) return null

  let m: RegExpMatchArray | null

  // YYYYMMDD
  if ((m = s.match(/^(\d{4})(\d{2})(\d{2})$/))) {
    const [, y, mm, dd] = m
    return `${y}-${mm}-${dd}`
  }
  // YYYY-MM-DD or variants
  if ((m = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/))) {
    const [, y, mm, dd] = m
    return `${String(y).padStart(4, '0')}-${String(mm).padStart(
      2,
      '0',
    )}-${String(dd).padStart(2, '0')}`
  }
  // MM-DD (ì—°ë„ ì—†ì„ ë•Œ)
  if ((m = s.match(/^(\d{1,2})-(\d{1,2})$/))) {
    const mm2 = Number(m[1])
    const dd2 = Number(m[2])
    const endY = Number(end.slice(0, 4))
    const cand1 = new Date(endY, mm2 - 1, dd2)
    const sDate = new Date(start)
    const eDate = new Date(end)
    if (cand1 >= sDate && cand1 <= eDate) return gYmd(cand1)
    const cand2 = new Date(endY - 1, mm2 - 1, dd2)
    return gYmd(cand2)
  }
  // MMDD
  if ((m = s.match(/^(\d{2})(\d{2})$/))) {
    const mm2 = Number(m[1])
    const dd2 = Number(m[2])
    const endY = Number(end.slice(0, 4))
    const cand1 = new Date(endY, mm2 - 1, dd2)
    const sDate = new Date(start)
    const eDate = new Date(end)
    if (cand1 >= sDate && cand1 <= eDate) return gYmd(cand1)
    const cand2 = new Date(endY - 1, mm2 - 1, dd2)
    return gYmd(cand2)
  }
  if (s.length > 10) return gNormalizeRegday(s.slice(0, 10), start, end)
  return null
}

function gNormalizeRowsToArray(rows: any[], start: string, end: string): GraphPoint[] {
  const tmp: Array<{ regday: string; price: number }> = []
  for (const r of rows) {
    const regRaw = gPickRegdayField(r)
    const reg = gNormalizeRegday(regRaw, start, end)
    const p = gParsePrice((r as any).price ?? (r as any).dpr1 ?? (r as any).value)
    if (reg && p != null) tmp.push({ regday: reg, price: p })
  }
  if (!tmp.length) return []
  const map = new Map<string, { sum: number; n: number }>()
  for (const { regday, price } of tmp) {
    const cur = map.get(regday)
    if (!cur) map.set(regday, { sum: price, n: 1 })
    else map.set(regday, { sum: cur.sum + price, n: cur.n + 1 })
  }
  return Array.from(map.entries())
    .map(([regday, v]) => ({ regday, price: v.sum / v.n }))
    .sort((a, b) => a.regday.localeCompare(b.regday))
}

function gInterpolateDaily(arr: GraphPoint[], start: string, end: string): GraphPoint[] {
  if (!arr.length) return []
  const obs = new Map(arr.map((x) => [x.regday, x.price]))
  const s = new Date(start)
  const e = new Date(end)
  const days: string[] = []
  for (let d = new Date(s); d <= e; d.setDate(d.getDate() + 1)) {
    days.push(gYmd(d))
  }
  const known = days
    .map((d, i) => (obs.has(d) ? { i, d, p: obs.get(d) as number } : null))
    .filter(
      (x): x is { i: number; d: string; p: number } =>
        !!x,
    )
  const out: GraphPoint[] = []
  for (let idx = 0; idx < days.length; idx++) {
    const d = days[idx]
    if (obs.has(d)) {
      out.push({ regday: d, price: obs.get(d) as number })
      continue
    }
    let left: { i: number; d: string; p: number } | null = null
    let right: { i: number; d: string; p: number } | null = null
    for (let k = known.length - 1; k >= 0; k--) {
      if (known[k].i < idx) {
        left = known[k]
        break
      }
    }
    for (let k = 0; k < known.length; k++) {
      if (known[k].i > idx) {
        right = known[k]
        break
      }
    }
    if (left && right) {
      const t = (idx - left.i) / (right.i - left.i)
      const p = left.p + (right.p - left.p) * t
      out.push({ regday: d, price: p })
    } else if (left) out.push({ regday: d, price: left.p })
    else if (right) out.push({ regday: d, price: right.p })
  }
  return out
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Home Summary (/home-summary) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const HOME_SUMMARY_VERSION = 'v2' // ğŸ” ìºì‹œ ë²„ì „ ì˜¬ë ¤ì„œ ì˜ˆì „ ë°ëª¨ ìºì‹œ ë¬´íš¨í™”

interface HomeSummaryItem {
  name: string
  item_name?: string
  kind_name?: string
  unit: string
  price: number
  level: number
  category_code?: string
  category_name?: string
  product_cls_code?: string
  emoji?: string
}

interface CategoryIndexRow {
  category_code: string
  category_name: string
  index: number
  level: number
  price?: number      // ì§€ìˆ˜ìš©: í”„ë¡ íŠ¸ì—ì„œëŠ” indexë§Œ ì“°ê³  priceëŠ” ë¹„ì›€
  unit: string        // 'ì '
  emoji?: string
}

/** ë‚´ë¶€ ê³„ì‚°ìš© ì •ê·œí™”ëœ ì¼ë³„ í–‰ */
interface NormalizedDailyRow {
  productCls: '01' | '02'
  categoryCode: string
  categoryName: string
  itemName: string
  kindName: string
  rankName: string
  unit: string
  price: number
}

interface StageRow extends NormalizedDailyRow {
  ratio: number
  stage: number
}

/** dailySalesList ì‘ë‹µì—ì„œ "í’ˆëª© í–‰"ìœ¼ë¡œ ë³´ì´ëŠ” ë…¸ë“œë§Œ ìˆ˜ì§‘ */
function hsCollectDailyRows(node: any, bag: any[] = []): any[] {
  if (node == null) return bag
  if (Array.isArray(node)) {
    for (const x of node) hsCollectDailyRows(x, bag)
    return bag
  }
  if (typeof node === 'object') {
    let keys: string[] = []
    try {
      keys = Object.keys(node)
    } catch {
      return bag
    }
    const lower = keys.map((k) => k.toLowerCase())
    const hasPrice = lower.includes('dpr1') || lower.includes('price')
    const hasItemName = lower.some((k) => k.includes('item_name') || k === 'itemname')
    if (hasPrice && hasItemName) {
      bag.push(node)
    }
    let values: any[] = []
    try {
      values = Object.values(node)
    } catch {
      return bag
    }
    for (const v of values) hsCollectDailyRows(v, bag)
  }
  return bag
}

function hsNormalizeDailyRow(raw: any, ch: '01' | '02'): NormalizedDailyRow | null {
  const price = gParsePrice(raw.dpr1 ?? raw.price ?? raw.current_price)
  if (price == null) return null

  const productCls: '01' | '02' = ch

  const categoryCodeRaw =
    raw.item_category_code ??
    raw.itemcategorycode ??
    raw.category_code ??
    raw.categorycode ??
    ''
  const categoryCode = String(categoryCodeRaw || '').padStart(3, '0')

  const categoryName =
    raw.item_category_name ??
    raw.itemcategoryname ??
    raw.category_name ??
    raw.categoryname ??
    ''

  const itemName = raw.item_name2 ?? raw.item_name ?? raw.itemname ?? ''
  const kindName = raw.kind_name2 ?? raw.kind_name ?? raw.kindname ?? ''
  const rankName = raw.rank_name ?? raw.rank ?? ''
  const unit = raw.unit ?? raw.unit_name ?? raw.product_unit ?? ''

  if (!itemName) return null

  return {
    productCls,
    categoryCode,
    categoryName: categoryName || 'ê¸°íƒ€',
    itemName,
    kindName,
    rankName,
    unit,
    price,
  }
}

function hsMedian(nums: number[]): number {
  if (!nums.length) return 0
  const sorted = [...nums].sort((a, b) => a - b)
  const mid = Math.floor(sorted.length / 2)
  if (sorted.length % 2 === 1) return sorted[mid]
  return (sorted[mid - 1] + sorted[mid]) / 2
}

/* ì´ëª¨ì§€ í—¬í¼ë“¤: ì¹´í…Œê³ ë¦¬ / í’ˆëª©ë³„ ëŒ€í‘œ ì´ëª¨ì§€ */

function hsPickCategoryEmoji(code: string, name: string): string {
  const c = code || ''
  const n = (name || '').toLowerCase()
  if (c.startsWith('11') || n.includes('ì‹ëŸ‰')) return 'ğŸŒ¾'
  if (c.startsWith('21') || n.includes('ì±„ì†Œ')) return 'ğŸ¥¬'
  if (c.startsWith('31') || n.includes('ê³¼ì¼')) return 'ğŸ'
  if (c.startsWith('41') || n.includes('ìˆ˜ì‚°')) return 'ğŸŸ'
  if (c.startsWith('51') || n.includes('ì¶•ì‚°')) return 'ğŸ¥©'
  return 'ğŸ›’'
}

function hsPickItemEmoji(r: NormalizedDailyRow | StageRow): string {
  const name = (r.itemName || '').toLowerCase()
  const cat = r.categoryCode || ''

  // ê³¼ì¼/ì±„ì†Œë¥˜
  if (name.includes('ì‚¬ê³¼')) return 'ğŸ'
  if (name === 'ë°°' || name.startsWith('ë°°(') || name.includes('ë°° ')) return 'ğŸ'
  if (name.includes('ë°°ì¶”')) return 'ğŸ¥¬'
  if (name.includes('ì–‘íŒŒ')) return 'ğŸ§…'
  if (name.includes('ëŒ€íŒŒ')) return 'ğŸŒ¿'
  if (name.includes('ê°ì')) return 'ğŸ¥”'
  if (name.includes('ê³ êµ¬ë§ˆ')) return 'ğŸ '
  if (name.includes('í† ë§ˆí† ')) return 'ğŸ…'
  if (name.includes('ì˜¤ì´')) return 'ğŸ¥’'
  if (name.includes('ìƒì¶”')) return 'ğŸ¥¬'
  if (name.includes('ë‹¹ê·¼')) return 'ğŸ¥•'
  if (name.includes('ë”¸ê¸°')) return 'ğŸ“'
  if (name.includes('ìˆ˜ë°•')) return 'ğŸ‰'
  if (name.includes('í¬ë„')) return 'ğŸ‡'
  if (name.includes('ë°”ë‚˜ë‚˜')) return 'ğŸŒ'
  if (name.includes('ì˜¤ë Œì§€') || name.includes('ê°ê·¤') || name.includes('ê·¤'))
    return 'ğŸŠ'
  if (name.includes('ì°¸ì™¸') || name.includes('ë©œë¡ ')) return 'ğŸˆ'

  // ì‹ëŸ‰ì‘ë¬¼
  if (name.includes('ìŒ€') || name.includes('í˜„ë¯¸')) return 'ğŸŒ¾'
  if (name.includes('ì½©')) return 'ğŸ«˜'

  // ì¶•ì‚°ë¬¼
  if (name.includes('ë¼ì§€ê³ ê¸°') || name.includes('ë¼ì§€')) return 'ğŸ¥©'
  if (name.includes('ì†Œê³ ê¸°') || name.includes('ì‡ ê³ ê¸°') || name.includes('ì†Œ '))
    return 'ğŸ¥©'
  if (name.includes('ë‹­ê³ ê¸°') || name.includes('ë‹­ ')) return 'ğŸ—'
  if (name.includes('ë‹¬ê±€') || name.includes('ê³„ë€')) return 'ğŸ¥š'

  // ìˆ˜ì‚°ë¬¼
  if (name.includes('ì˜¤ì§•ì–´')) return 'ğŸ¦‘'
  if (name.includes('ìƒˆìš°') || name.includes('ëŒ€í•˜')) return 'ğŸ¦'
  if (name.includes('ê°ˆì¹˜') || name.includes('ëª…íƒœ') || name.includes('ëŒ€êµ¬'))
    return 'ğŸŸ'

  // ì¹´í…Œê³ ë¦¬ fallback
  if (cat.startsWith('41')) return 'ğŸŸ'
  if (cat.startsWith('51')) return 'ğŸ¥©'
  if (cat.startsWith('31')) return 'ğŸ'
  if (cat.startsWith('21')) return 'ğŸ¥¬'
  if (cat.startsWith('11')) return 'ğŸŒ¾'

  return 'ğŸ'
}

/** ì¹´í…Œê³ ë¦¬ë³„ "ì¤‘ì•™ê°’ ëŒ€ë¹„ í˜„ì¬ê°€ê²© ë¹„ìœ¨"ì„ ê¸°ì¤€ìœ¼ë¡œ 4ë‹¨ê³„ ìŠ¤í…Œì´ì§€ ê³„ì‚° */
function hsComputeStages(rows: NormalizedDailyRow[]): StageRow[] {
  const byCat = new Map<string, NormalizedDailyRow[]>()
  for (const r of rows) {
    const key = r.categoryCode || `${r.productCls}:000`
    const arr = byCat.get(key)
    if (arr) arr.push(r)
    else byCat.set(key, [r])
  }

  const medians = new Map<string, number>()
  for (const [key, arr] of byCat.entries()) {
    const ps = arr.map((r) => r.price).filter((p) => p > 0)
    medians.set(key, hsMedian(ps))
  }

  const out: StageRow[] = []
  for (const r of rows) {
    const key = r.categoryCode || `${r.productCls}:000`
    const base = medians.get(key) || r.price || 1
    const ratio = base > 0 ? r.price / base : 1

    // RELAXED ê¸°ì¤€: 0.85â†“ ë§¤ìš° ì‹¸ë‹¤, 0.85~1.0 ì‹¸ë‹¤, 1.0~1.15 ë³´í†µ, 1.15â†‘ ë¹„ì‹¸ë‹¤
    let stage = 2
    if (ratio <= 0.85) stage = 4 // ì‹¸ë‹¤ (GREEN)
    else if (ratio <= 1.0) stage = 3 // ê´œì°®ë‹¤ (YELLOW)
    else if (ratio <= 1.15) stage = 2 // ë³´í†µ (ORANGE)
    else stage = 1 // ë¹„ì‹¸ë‹¤ (RED)

    out.push({ ...r, ratio, stage })
  }
  return out
}

/** ì¹´í…Œê³ ë¦¬ë³„ ì§€ìˆ˜ (0~100ì ) ë° ë ˆë²¨(1~4) ê³„ì‚° */
function hsBuildCategoryIndex(rows: StageRow[]): CategoryIndexRow[] {
  const byCat = new Map<string, { name: string; rows: StageRow[] }>()
  for (const r of rows) {
    const code = r.categoryCode || '000'
    const key = code
    const prev = byCat.get(key)
    if (prev) prev.rows.push(r)
    else
      byCat.set(key, {
        name: r.categoryName || code,
        rows: [r],
      })
  }

  const result: CategoryIndexRow[] = []
  for (const [code, { name, rows }] of byCat.entries()) {
    const total = rows.length || 1
    const good = rows.filter((r) => r.stage >= 3).length
    const rawIndex = (good / total) * 100
    const index = Math.round(rawIndex * 10) / 10

    let level = 2
    if (index >= 75) level = 4
    else if (index >= 55) level = 3
    else if (index >= 40) level = 2
    else level = 1

    const emoji = hsPickCategoryEmoji(code, name)

    result.push({
      category_code: code,
      category_name: name,
      index,
      level,
      unit: 'ì ',
      emoji,
    })
  }

  result.sort((a, b) => a.category_code.localeCompare(b.category_code))
  return result
}

/** ì±„ë„ë³„ TOP3 (stage>=3 ìš°ì„ , ê·¸ ë‹¤ìŒ ratio/ê°€ê²©/ì¹´í…Œê³ ë¦¬ ë‹¤ì–‘ì„±) */
function hsBuildTop3(rows: StageRow[], ch: '01' | '02'): HomeSummaryItem[] {
  const channelRows = rows.filter((r) => r.productCls === ch)
  if (!channelRows.length) return []

  // ê°™ì€ í’ˆëª©/í’ˆì¢…/ë“±ê¸‰ì€ "ê°€ì¥ ì¢‹ì€" í–‰ í•˜ë‚˜ë§Œ ìœ ì§€
  const byKey = new Map<string, StageRow>()
  for (const r of channelRows) {
    const key = `${r.categoryCode}:${r.itemName}:${r.kindName}:${r.rankName}`
    const prev = byKey.get(key)
    if (!prev) {
      byKey.set(key, r)
      continue
    }
    // stage ë†’ì€ ê²ƒ, ê·¸ ë‹¤ìŒ ratio ë‚®ì€ ê²ƒ, ê·¸ ë‹¤ìŒ ê°€ê²© ì‹¼ ê²ƒ ìš°ì„ 
    if (r.stage > prev.stage) {
      byKey.set(key, r)
      continue
    }
    if (r.stage === prev.stage) {
      if (r.ratio < prev.ratio) {
        byKey.set(key, r)
        continue
      }
      if (r.ratio === prev.ratio && r.price < prev.price) {
        byKey.set(key, r)
        continue
      }
    }
  }

  const deduped = Array.from(byKey.values())
  deduped.sort((a, b) => {
    if (b.stage !== a.stage) return b.stage - a.stage
    if (a.ratio !== b.ratio) return a.ratio - b.ratio
    if (a.price !== b.price) return a.price - b.price
    return (a.itemName + a.kindName).localeCompare(b.itemName + b.kindName)
  })

  const chosen: StageRow[] = []
  const usedKey = new Set<string>()
  const usedCategory = new Set<string>()

  // 1ë‹¨ê³„: stage >= 3, ì¹´í…Œê³ ë¦¬ ë‹¤ì–‘í•˜ê²Œ (í•œ ì¹´í…Œê³ ë¦¬ë‹¹ 1ê°œ)
  for (const r of deduped) {
    if (r.stage < 3) continue
    const cat = r.categoryCode || ''
    const fullKey = `${r.categoryCode}:${r.itemName}:${r.kindName}:${r.rankName}`
    if (usedKey.has(fullKey) || usedCategory.has(cat)) continue
    chosen.push(r)
    usedKey.add(fullKey)
    usedCategory.add(cat)
    if (chosen.length >= 3) break
  }

  // 2ë‹¨ê³„: ê·¸ë˜ë„ 3ê°œê°€ ì•ˆ ë˜ë©´ stage >= 3 ì „ì²´ì—ì„œ ì±„ìš°ê¸° (ì¹´í…Œê³ ë¦¬ ì¤‘ë³µ í—ˆìš©)
  if (chosen.length < 3) {
    for (const r of deduped) {
      if (r.stage < 3) continue
      const fullKey = `${r.categoryCode}:${r.itemName}:${r.kindName}:${r.rankName}`
      if (usedKey.has(fullKey)) continue
      chosen.push(r)
      usedKey.add(fullKey)
      if (chosen.length >= 3) break
    }
  }

  // 3ë‹¨ê³„: ì•„ì§ë„ ë¶€ì¡±í•˜ë©´ stage >= 2 ê¹Œì§€ í—ˆìš©
  if (chosen.length < 3) {
    for (const r of deduped) {
      if (r.stage < 2) continue
      const fullKey = `${r.categoryCode}:${r.itemName}:${r.kindName}:${r.rankName}`
      if (usedKey.has(fullKey)) continue
      chosen.push(r)
      usedKey.add(fullKey)
      if (chosen.length >= 3) break
    }
  }

  const result: HomeSummaryItem[] = chosen.slice(0, 3).map((r) => {
    const displayName = r.kindName ? `${r.itemName}/${r.kindName}` : r.itemName
    const emoji = hsPickItemEmoji(r)
    return {
      name: displayName,
      item_name: r.itemName,
      kind_name: r.kindName,
      unit: r.unit,
      price: Math.round(r.price),
      level: r.stage,
      category_code: r.categoryCode,
      category_name: r.categoryName,
      product_cls_code: r.productCls,
      emoji,
    }
  })

  return result
}

/** ì£¼ì–´ì§„ ë‚ ì§œì˜ dailySalesList í•œ ë²ˆ í˜¸ì¶œ */
async function hsFetchDailyOnce(
  env: Env,
  ch: '01' | '02',
  regday: string,
): Promise<NormalizedDailyRow[]> {
  const base = getKamisBase(env)
  const sp = buildKamisParams(env, 'dailySalesList', {
    p_product_cls_code: ch,
    p_regday: regday,
  })
  const target = `${base}?${sp.toString()}`

  const { signal, clear } = withAbortTimeout(12_000)
  try {
    const res = await fetch(target, { method: 'GET', signal })
    const bodyText = await res.text()
    clear()

    if (!res.ok) {
      console.warn(
        '[home-summary] dailySalesList error',
        ch,
        regday,
        res.status,
        bodyText.slice(0, 200),
      )
      return []
    }

    let body: any
    try {
      body = JSON.parse(bodyText)
    } catch (e: any) {
      console.warn('[home-summary] JSON parse failed', e?.message || e)
      return []
    }

    const rawRows = hsCollectDailyRows(body)
    const norm: NormalizedDailyRow[] = []
    for (const r of rawRows) {
      const nr = hsNormalizeDailyRow(r, ch)
      if (nr) norm.push(nr)
    }
    return norm
  } catch (e: any) {
    clear()
    console.warn('[home-summary] fetch failed', ch, regday, e?.message || e)
    return []
  }
}

/** ìµœì‹  ì˜ì—…ì¼(ìµœëŒ€ Nì¼ ë’¤ë¡œ)ì„ ì°¾ì•„ ì¼ë³„ í–‰ ë°˜í™˜ */
async function hsFetchLatestDaily(
  env: Env,
  ch: '01' | '02',
  maxBackDays = 7,
): Promise<{ rows: NormalizedDailyRow[]; regday: string | null }> {
  const now = new Date()
  for (let offset = 0; offset < maxBackDays; offset++) {
    const d = new Date(now.getTime())
    d.setDate(d.getDate() - offset)
    const regday = gYmd(d)
    const rows = await hsFetchDailyOnce(env, ch, regday)
    if (rows.length) return { rows, regday }
  }
  return { rows: [], regday: null }
}

/** KAMIS ì‹¤íŒ¨ ì‹œì—ë„ UIê°€ "ì¤€ë¹„ì¤‘"ë§Œ ì•ˆ ë³´ì´ë„ë¡ í•˜ëŠ” fallback ìš”ì•½ */
function hsBuildFallbackSummary() {
  return {
    mode: 'fallback' as const,
    reason: 'kamis_empty',
    indexAll: [] as CategoryIndexRow[],
    index: [] as CategoryIndexRow[],
    retailTop3: [] as HomeSummaryItem[],
    wholesaleTop3: [] as HomeSummaryItem[],
    generatedAt: new Date().toISOString(),
  }
}

/** /home-summary ì—ì„œ ì‚¬ìš©í•  ìµœì¢… ìš”ì•½ */
async function buildHomeSummary(env: Env) {
  const today = new Date()
  const ymd = gYmd(today)
  const cacheKey = `homeSummary.${HOME_SUMMARY_VERSION}:${ymd}`
  const nowMs = Date.now()
  const kstHour = getKstHour()

  // 1) KV ìºì‹œ ë¨¼ì € ì‹œë„ (1ì‹œê°„ ì´ë‚´ë©´ ë¬´ì¡°ê±´ ì‚¬ìš©, 1ì‹œê°„ ë„˜ì–´ë„ KST 0~12ì‹œëŠ” í—ˆìš©)
  try {
    const cached = await env.PRICE_CACHE.get(cacheKey)
    if (cached) {
      try {
        const parsed = JSON.parse(cached) as any
        const hasData =
          (parsed.indexAll && parsed.indexAll.length) ||
          (parsed.index && parsed.index.length) ||
          (parsed.retailTop3 && parsed.retailTop3.length) ||
          (parsed.wholesaleTop3 && parsed.wholesaleTop3.length)

        const tsRaw: string | undefined =
          typeof parsed.generatedAt === 'string'
            ? parsed.generatedAt
            : typeof parsed.cachedAt === 'string'
            ? parsed.cachedAt
            : undefined
        let isFresh = false
        if (tsRaw) {
          const ts = Date.parse(tsRaw)
          if (!Number.isNaN(ts)) {
            isFresh = nowMs - ts <= LOGICAL_TTL_MS
          }
        }

        if (hasData && (isFresh || kstHour < 12)) {
          return parsed
        }
      } catch (e: any) {
        console.warn('[home-summary] cached JSON parse failed, ignore', e?.message || e)
      }
    }
  } catch (e: any) {
    console.warn('[home-summary] PRICE_CACHE.get failed', e?.message || e)
  }

  // 2) ìµœì‹  ì˜ì—…ì¼ ê¸°ì¤€ ì†Œë§¤/ë„ë§¤ ë°ì´í„° ì¡°íšŒ
  const [retailRes, wholesaleRes] = await Promise.all([
    hsFetchLatestDaily(env, '01'),
    hsFetchLatestDaily(env, '02'),
  ])

  const allRows: NormalizedDailyRow[] = [...retailRes.rows, ...wholesaleRes.rows]

  // 2-1) KAMIS ìª½ì´ ì™„ì „ ë¹„ì–´ ìˆìœ¼ë©´ â†’ ë”ë¯¸ ëŒ€ì‹  ë¹ˆ ìš”ì•½ ì‚¬ìš©
  if (!allRows.length) {
    console.warn('[home-summary] no KAMIS rows, using empty fallback summary')
    const fallback = hsBuildFallbackSummary()
    try {
      await env.PRICE_CACHE.put(cacheKey, JSON.stringify(fallback), {
        expirationTtl: HARD_TTL_SECONDS,
      })
    } catch (e: any) {
      console.warn('[home-summary] PRICE_CACHE.put fallback failed', e?.message || e)
    }
    return fallback
  }

  // 3) ë‹¨ê³„/ì§€ìˆ˜ ê³„ì‚°
  const staged = hsComputeStages(allRows)
  const indexAll = hsBuildCategoryIndex(staged)
  const retailTop3 = hsBuildTop3(staged, '01')
  const wholesaleTop3 = hsBuildTop3(staged, '02')

  const priceDate = retailRes.regday || wholesaleRes.regday || null

  const summary = {
    mode: 'live' as const,
    indexAll,
    index: indexAll,
    retailTop3,
    wholesaleTop3,
    price_date: priceDate,
    generatedAt: new Date().toISOString(),
  }

  try {
    await env.PRICE_CACHE.put(cacheKey, JSON.stringify(summary), {
      expirationTtl: HARD_TTL_SECONDS,
    })
  } catch (e: any) {
    console.warn('[home-summary] PRICE_CACHE.put failed', e?.message || e)
  }

  return summary
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ /prices â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

interface PriceCacheEntry {
  status: number
  body: string
  contentType?: string
  cachedAt?: string
}

async function handlePrices(req: Request, env: Env, cors: Record<string, string>) {
  const url = new URL(req.url)

  // 1) Rate limit (KV ì˜¤ë¥˜ ë°©íƒ„ ì²˜ë¦¬)
  try {
    if (env.FRUIT_CACHE) {
      const ip = getClientIP(req)
      const bucket = new Date().toISOString().slice(0, 16)
      const rlKey = `rl:${ip}:${bucket}`

      let count = 0
      try {
        const raw = await env.FRUIT_CACHE.get(rlKey)
        count = parseInt(raw || '0', 10) || 0
      } catch (e: any) {
        console.warn('[handlePrices] FRUIT_CACHE.get rate-limit ì‹¤íŒ¨:', e?.message || e)
      }

      if (count >= 120) {
        return json({ error: 'RATE_LIMITED' }, cors, { status: 429 })
      }

      try {
        await env.FRUIT_CACHE.put(rlKey, String(count + 1), { expirationTtl: 90 })
      } catch (e: any) {
        console.warn('[handlePrices] FRUIT_CACHE.put rate-limit ì‹¤íŒ¨:', e?.message || e)
      }
    }
  } catch {
    // rate limit ë¡œì§ ìì²´ê°€ ê¹¨ì ¸ë„, ìš”ì²­ì€ ê³„ì† í˜ë ¤ë³´ëƒ„
  }

  // 2) Upstream ìš”ì²­ ì¤€ë¹„
  const base = getKamisBase(env)
  const sp = new URLSearchParams(url.search)

  if (env.KAMIS_CERT_ID && !sp.has('p_cert_id')) sp.set('p_cert_id', env.KAMIS_CERT_ID)
  if (env.KAMIS_CERT_KEY && !sp.has('p_cert_key')) sp.set('p_cert_key', env.KAMIS_CERT_KEY)
  if (!sp.has('p_returntype')) sp.set('p_returntype', 'json')

  const entries = Array.from(sp.entries()).sort(([a], [b]) =>
    a < b ? -1 : a > b ? 1 : 0,
  )
  const sorted = new URLSearchParams()
  for (const [k, v] of entries) sorted.append(k, v)
  const queryString = sorted.toString()
  const cacheKey = `prices.v1:${queryString}`

  const nowMs = Date.now()
  const kstHour = getKstHour()
  let cachedEntry: PriceCacheEntry | null = null
  let cachedIsFresh = false

  // 3) ìºì‹œ ì¡°íšŒ
  try {
    if (env.FRUIT_CACHE) {
      const cached = await env.FRUIT_CACHE.get(cacheKey)
      if (cached) {
        try {
          const parsed = JSON.parse(cached) as any
          const entry: PriceCacheEntry = {
            status: parsed.status ?? 200,
            body: parsed.body ?? '',
            contentType: parsed.contentType,
            cachedAt: parsed.cachedAt,
          }

          if (entry.body) {
            if (entry.cachedAt) {
              const ts = Date.parse(entry.cachedAt)
              if (!Number.isNaN(ts)) {
                cachedIsFresh = nowMs - ts <= LOGICAL_TTL_MS
              }
            }
            cachedEntry = entry
          }
        } catch (e: any) {
          console.warn('[handlePrices] ìºì‹œ JSON íŒŒì‹± ì‹¤íŒ¨, ë¬´ì‹œí•˜ê³  íŒ¨ìŠ¤:', e?.message || e)
        }
      }
    }
  } catch (e: any) {
    console.warn('[handlePrices] FRUIT_CACHE.get cache ì‹¤íŒ¨:', e?.message || e)
  }

  // 3-1) ìºì‹œê°€ ìˆê³  (1ì‹œê°„ ì´ë‚´ì´ê±°ë‚˜ / ë˜ëŠ” KST 0~12ì‹œ)ì´ë©´ ë°”ë¡œ ì‚¬ìš©
  if (cachedEntry && (cachedIsFresh || kstHour < 12)) {
    const headers: Record<string, string> = {
      ...SEC_HEADERS,
      ...cors,
    }
    const bodyTrimmed = cachedEntry.body.trim()
    const ct =
      cachedEntry.contentType ||
      (bodyTrimmed.startsWith('{') || bodyTrimmed.startsWith('[')
        ? 'application/json; charset=utf-8'
        : 'text/xml; charset=utf-8')
    headers['Content-Type'] = ct
    headers['X-Cache'] = cachedIsFresh ? 'HIT' : 'STALE'
    return new Response(cachedEntry.body, {
      status: cachedEntry.status || 200,
      headers,
    })
  }

  const target = `${base}?${sp.toString()}`

  // 4) ì—…ìŠ¤íŠ¸ë¦¼ í˜¸ì¶œ + ìºì‹œ ì €ì¥
  const { signal, clear } = withAbortTimeout(12_000)
  try {
    const upstream = await fetch(target, { method: 'GET', signal })
    const body = await upstream.text()
    const upstreamCT = upstream.headers.get('content-type') || ''
    clear()

    const ct =
      upstreamCT ||
      (body.trim().startsWith('{') || body.trim().startsWith('[')
        ? 'application/json; charset=utf-8'
        : 'text/xml; charset=utf-8')

    const headers: Record<string, string> = {
      ...SEC_HEADERS,
      ...cors,
      'Content-Type': ct,
      'X-Upstream-URL': target,
      'X-Cache': 'MISS',
    }

    // ì—…ìŠ¤íŠ¸ë¦¼ì´ ì •ìƒì¼ ë•Œë§Œ ìºì‹œ ì €ì¥
    if (upstream.ok) {
      try {
        if (env.FRUIT_CACHE) {
          const entry: PriceCacheEntry = {
            status: upstream.status,
            body,
            contentType: ct,
            cachedAt: new Date().toISOString(),
          }
          await env.FRUIT_CACHE.put(cacheKey, JSON.stringify(entry), {
            expirationTtl: HARD_TTL_SECONDS,
          })
        }
      } catch (e: any) {
        console.warn('[handlePrices] FRUIT_CACHE.put cache ì‹¤íŒ¨:', e?.message || e)
      }
    } else {
      // ì—…ìŠ¤íŠ¸ë¦¼ ìƒíƒœì½”ë“œê°€ 200ì´ ì•„ë‹ˆë©´ ë¡œê·¸ë§Œ ë‚¨ê¸°ê³ , ì•„ë˜ì—ì„œ fallback ì‚¬ìš©
      console.warn(
        '[handlePrices] upstream non-ok',
        upstream.status,
        body.slice(0, 200),
      )
      if (cachedEntry) {
        // ì´ì „ ìºì‹œë¼ë„ ìˆìœ¼ë©´ ê·¸ê±¸ ëŒë ¤ì£¼ê³  5xxë¥¼ í”¼í•¨
        const headersFallback: Record<string, string> = {
          ...SEC_HEADERS,
          ...cors,
        }
        const trimmed = cachedEntry.body.trim()
        const ctFallback =
          cachedEntry.contentType ||
          (trimmed.startsWith('{') || trimmed.startsWith('[')
            ? 'application/json; charset=utf-8'
            : 'text/xml; charset=utf-8')
        headersFallback['Content-Type'] = ctFallback
        headersFallback['X-Cache'] = 'STALE_FALLBACK'
        return new Response(cachedEntry.body, {
          status: cachedEntry.status || 200,
          headers: headersFallback,
        })
      }
      // ìºì‹œë„ ì—†ìœ¼ë©´ ê¸°ì¡´ì²˜ëŸ¼ ì—ëŸ¬ ì‘ë‹µ
      return json(
        {
          error: 'UPSTREAM_ERROR',
          message: `status ${upstream.status}`,
          upstream: 'kamis',
        },
        cors,
        { status: 502 },
      )
    }

    return new Response(body, { status: upstream.status, headers })
  } catch (e: any) {
    clear()
    console.warn('[handlePrices] upstream fetch ì‹¤íŒ¨:', e?.message || e)
    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë“±ì—ì„œë„ ìºì‹œ fallback
    if (cachedEntry) {
      const headers: Record<string, string> = {
        ...SEC_HEADERS,
        ...cors,
      }
      const trimmed = cachedEntry.body.trim()
      const ct =
        cachedEntry.contentType ||
        (trimmed.startsWith('{') || trimmed.startsWith('[')
          ? 'application/json; charset=utf-8'
          : 'text/xml; charset=utf-8')
      headers['Content-Type'] = ct
      headers['X-Cache'] = 'STALE_FALLBACK'
      return new Response(cachedEntry.body, {
        status: cachedEntry.status || 200,
        headers,
      })
    }

    return json(
      { error: 'UPSTREAM_ERROR', message: String(e?.message || e), upstream: 'kamis' },
      cors,
      { status: 502 },
    )
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ /graphs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

interface GraphCacheEntry {
  series: GraphPoint[]
  cachedAt?: string
}

async function handleGraphs(req: Request, env: Env, cors: Record<string, string>) {
  if (req.method !== 'GET') {
    return json({ error: 'method_not_allowed' }, cors, { status: 405 })
  }

  const url = new URL(req.url)

  const itemCode =
    url.searchParams.get('item_code') ?? url.searchParams.get('itemCode') ?? ''
  if (!itemCode) {
    return json({ error: 'missing_item_code' }, cors, { status: 400 })
  }

  const chRaw =
    url.searchParams.get('product_cls_code') ??
    url.searchParams.get('productClsCode') ??
    url.searchParams.get('ch') ??
    '01'
  const ch = chRaw === '02' ? '02' : '01'

  const kindRaw =
    url.searchParams.get('kind_code') ?? url.searchParams.get('kindCode') ?? '00'
  const kindCode = String(kindRaw).padStart(2, '0')

  const rankCode =
    url.searchParams.get('rank_code') ?? url.searchParams.get('rankCode') ?? ''

  const daysParam = url.searchParams.get('days')
  let days = 30
  if (daysParam) {
    const n = parseInt(daysParam, 10)
    if (Number.isFinite(n) && n > 0) days = n
  }
  if (days > 400) days = 400

  const cacheKey = `graph.v1:${ch}:${itemCode}:${kindCode}:${rankCode}:${days}`

  const nowMs = Date.now()
  const kstHour = getKstHour()
  let cachedSeries: GraphPoint[] | null = null
  let cachedIsFresh = false

  // PRICE_CACHE ì—ì„œ ê·¸ë˜í”„ ìºì‹œ ì¡°íšŒ
  try {
    const cached = await env.PRICE_CACHE.get(cacheKey)
    if (cached) {
      try {
        const parsed = JSON.parse(cached)
        if (Array.isArray(parsed)) {
          // ì˜ˆì „ í¬ë§·: ê·¸ëƒ¥ series ë°°ì—´ë§Œ ì €ì¥
          cachedSeries = parsed as GraphPoint[]
        } else if (parsed && Array.isArray((parsed as any).series)) {
          const entry = parsed as GraphCacheEntry
          cachedSeries = entry.series
          if (entry.cachedAt) {
            const ts = Date.parse(entry.cachedAt)
            if (!Number.isNaN(ts)) {
              cachedIsFresh = nowMs - ts <= LOGICAL_TTL_MS
            }
          }
        }
      } catch (e: any) {
        console.warn('[handleGraphs] cached JSON íŒŒì‹± ì‹¤íŒ¨:', e?.message || e)
      }
    }
  } catch (e: any) {
    console.warn('[handleGraphs] PRICE_CACHE.get ì‹¤íŒ¨:', e?.message || e)
  }

  if (cachedSeries && (cachedIsFresh || kstHour < 12)) {
    return json(cachedSeries, cors, {
      headers: { 'X-Cache': cachedIsFresh ? 'HIT' : 'STALE' },
    })
  }

  const { start, end } = gDateRangeDays(days)
  const action =
    ch === '01' ? 'periodRetailProductList' : 'periodWholesaleProductList'
  const base = getKamisBase(env)

  const ranges = gSplitRanges(start, end, 120)
  const all: GraphPoint[] = []

  for (let i = 0; i < ranges.length; i++) {
    const [rs, re] = ranges[i]
    const sp = buildKamisParams(env, action, {
      p_itemcode: itemCode,
      p_kindcode: kindCode,
      p_productrankcode: rankCode,
      p_startday: rs,
      p_endday: re,
      p_countrycode: '',
      p_convert_kg_yn: 'N',
    })

    const target = `${base}?${sp.toString()}`
    const { signal, clear } = withAbortTimeout(12_000)

    try {
      const upstream = await fetch(target, { method: 'GET', signal })
      const body = await upstream.text()
      clear()

      if (!upstream.ok) {
        console.warn(
          `[handleGraphs] upstream error ${i + 1}/${ranges.length}`,
          upstream.status,
          body.slice(0, 200),
        )
        continue
      }

      let jsonBody: any
      try {
        jsonBody = JSON.parse(body)
      } catch (e: any) {
        console.warn('[handleGraphs] JSON íŒŒì‹± ì‹¤íŒ¨:', e?.message || e)
        continue
      }

      const rows = gDeepCollectRows(jsonBody)
      const arr = gNormalizeRowsToArray(rows, rs, re)
      const filled = gInterpolateDaily(arr, rs, re)
      if (filled.length) {
        all.push(...filled)
      }
    } catch (e: any) {
      clear()
      console.warn(
        `[handleGraphs] range ${i + 1}/${ranges.length} fetch ì‹¤íŒ¨:`,
        e?.message || e,
      )
    }
  }

  // ê°™ì€ ë‚ ì§œê°€ ì—¬ëŸ¬ ë²ˆ ë‚˜ì˜¤ë©´ í‰ê· 
  const map = new Map<string, { sum: number; n: number }>()
  for (const d of all) {
    const cur = map.get(d.regday)
    if (!cur) map.set(d.regday, { sum: d.price, n: 1 })
    else map.set(d.regday, { sum: cur.sum + d.price, n: cur.n + 1 })
  }

  let series: GraphPoint[] = Array.from(map.entries())
    .map(([regday, v]) => ({ regday, price: v.sum / v.n }))
    .sort((a, b) => a.regday.localeCompare(b.regday))

  // ìƒˆë¡œ êµ¬í•œ ê²Œ ë¹„ì—ˆëŠ”ë° ì˜ˆì „ ìºì‹œê°€ ìˆìœ¼ë©´ ê·¸ê±¸ fallback ìœ¼ë¡œ ì‚¬ìš©
  if (!series.length && cachedSeries) {
    return json(cachedSeries, cors, {
      headers: { 'X-Cache': 'STALE_FALLBACK' },
    })
  }

  // PRICE_CACHE ì— ì €ì¥
  try {
    const entry: GraphCacheEntry = {
      series,
      cachedAt: new Date().toISOString(),
    }
    await env.PRICE_CACHE.put(cacheKey, JSON.stringify(entry), {
      expirationTtl: HARD_TTL_SECONDS,
    })
  } catch (e: any) {
    console.warn('[handleGraphs] PRICE_CACHE.put ì‹¤íŒ¨:', e?.message || e)
  }

  return json(series, cors, {
    headers: { 'X-Cache': 'MISS' },
  })
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ AUTH logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function insertAuthEvent(env: Env, row: Record<string, any>) {
  const { supabaseUrl, serviceKey } = getSupabaseAdminCred(env)
  const table = env.SUPABASE_TABLE || 'auth_events'
  if (!supabaseUrl || !serviceKey) return { ok: false, disabled: true }

  const endpoint = `${supabaseUrl.replace(/\/+$/, '')}/rest/v1/${encodeURIComponent(
    table,
  )}`
  const res = await fetch(endpoint, {
    method: 'POST',
    headers: {
      apikey: serviceKey,
      Authorization: `Bearer ${serviceKey}`,
      'Content-Type': 'application/json',
      Prefer: 'return=minimal',
    },
    body: JSON.stringify(row),
  })
  return { ok: res.ok, status: res.status }
}

async function queryAuthEvents(env: Env, limit = 50) {
  const { supabaseUrl, serviceKey } = getSupabaseAdminCred(env)
  const table = env.SUPABASE_TABLE || 'auth_events'
  if (!supabaseUrl || !serviceKey)
    return { ok: false, disabled: true, items: [] as any[] }

  const endpoint = new URL(
    `${supabaseUrl.replace(/\/+$/, '')}/rest/v1/${encodeURIComponent(table)}`,
  )
  endpoint.searchParams.set('select', '*')
  endpoint.searchParams.set('order', 'ts.desc')
  endpoint.searchParams.set('limit', String(Math.min(Math.max(limit, 1), 200)))
  const res = await fetch(endpoint.toString(), {
    headers: { apikey: serviceKey, Authorization: `Bearer ${serviceKey}` },
  })
  if (!res.ok) return { ok: false, status: res.status, items: [] as any[] }
  return { ok: true, items: (await res.json()) as any[] }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Item popularity (click_events) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function getAdminClient(env: Env) {
  const { supabaseUrl, serviceKey } = getSupabaseAdminCred(env)
  if (!supabaseUrl || !serviceKey) return null
  return createClient(supabaseUrl, serviceKey, { auth: { persistSession: false } })
}

async function insertClickEvent(
  env: Env,
  row: {
    item_code: string
    category_code?: string | null
    product_cls_code?: string | null
    detail_key?: string | null
    source?: string | null
    client_id?: string | null
    item_type?: string | null
    action?: string | null
  },
) {
  const admin = getAdminClient(env)
  if (!admin) return { ok: false, disabled: true }

  const payload: any = {
    item_code: row.item_code,
    category_code: row.category_code ?? null,
    product_cls_code: row.product_cls_code ?? null,
    detail_key: row.detail_key ?? null,
    source: row.source ?? null,
    client_id: row.client_id ?? null,
    item_type: row.item_type ?? 'detail',
    action: row.action ?? 'view',
  }

  const { error } = await admin.from('click_events').insert(payload)
  if (error) {
    return {
      ok: false,
      error: { code: (error as any).code, message: (error as any).message },
    }
  }
  return { ok: true }
}

async function queryItemPopularity(env: Env, limit = 500) {
  const admin = getAdminClient(env)
  if (!admin) {
    return { ok: false, disabled: true, items: [] as any[] }
  }

  const { data, error } = await admin
    .from('item_popularity')
    .select('item_code, click_count')
    .order('click_count', { ascending: false })
    .limit(Math.min(Math.max(limit, 1), 1000))

  if (error) {
    return {
      ok: false,
      items: [] as any[],
      error: { code: (error as any).code, message: (error as any).message },
    }
  }

  return { ok: true, items: data || [] }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Alerts (skeleton) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function handleAlerts(req: Request, _env: Env, cors: Record<string, string>) {
  if (req.method === 'GET') return json({ items: [] }, cors)
  if (req.method === 'POST') {
    const payload = await readJSON<any>(req).catch(() => ({}))
    return json({ ok: true, received: payload }, cors)
  }
  return json({ error: 'method_not_allowed' }, cors, { status: 405 })
}

async function dispatchAlerts(_env: Env) {
  return { ok: true, sent: 0 }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Account delete ë³´ì¡° ìœ í‹¸ (RLS ì¹œí™”) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

type PgErr = { code?: string; message?: string; details?: string; hint?: string }

function isIgnorableNoTableOrColumn(err: PgErr) {
  const code = (err.code || '').toUpperCase()
  const msg = (err.message || '').toLowerCase()

  return (
    code === '42P01' ||
    code === '42703' ||
    code === 'PGRST205' ||
    (msg.includes('relation') && msg.includes('does not exist')) ||
    (msg.includes('table') && msg.includes('does not exist')) ||
    (msg.includes('schema cache') && msg.includes('could not find the table'))
  )
}

function isNoRows(err: PgErr) {
  return (err.code || '').toUpperCase() === 'PGRST116'
}

async function tryDeleteByAnyKey(
  admin: ReturnType<typeof createClient>,
  table: string,
  candidates: Array<[string, string]>,
) {
  for (const pair of candidates) {
    if (!pair) continue
    const [col, val] = pair
    try {
      const { error } = await admin.from(table).delete().eq(col, val)
      if (!error) return { ok: true, used: col }
      if (isNoRows(error)) return { ok: true, used: col, note: 'no_rows' }
      if (isIgnorableNoTableOrColumn(error)) continue
      return { ok: false, error: { table, col, code: error.code, message: error.message } }
    } catch (e: any) {
      const code = String(e?.code || '')
      const message = String(e?.message || e)
      if (isIgnorableNoTableOrColumn({ code, message })) continue
      return { ok: false, error: { table, col, code, message } }
    }
  }
  return { ok: true, skippedAllKeys: true }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ /v1/account/delete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function handleAccountDelete(req: Request, env: Env, cors: Record<string, string>) {
  if (req.method !== 'POST') return json({ error: 'method_not_allowed' }, cors, { status: 405 })

  const auth = req.headers.get('Authorization') || ''
  const token = auth.replace(/^Bearer\s+/i, '').trim()
  if (!token) return json({ error: 'unauthorized' }, cors, { status: 401 })

  const { supabaseUrl, serviceKey } = getSupabaseAdminCred(env)
  if (!supabaseUrl || !serviceKey)
    return json({ error: 'server_misconfigured' }, cors, { status: 500 })

  try {
    const admin = createClient(supabaseUrl, serviceKey, { auth: { persistSession: false } })

    const { data: userRes, error: getErr } = await admin.auth.getUser(token)
    if (getErr || !userRes?.user) return json({ error: 'unauthorized' }, cors, { status: 401 })
    const uid = userRes.user.id

    const ip = getClientIP(req)
    const slot = Math.floor(Date.now() / 600_000)
    const rlKey = `rl:del:${ip}:${slot}`
    const cnt = parseInt((await env.FRUIT_CACHE.get(rlKey)) || '0', 10)
    if (cnt >= 5) return json({ error: 'RATE_LIMITED' }, cors, { status: 429 })
    await env.FRUIT_CACHE.put(rlKey, String(cnt + 1), { expirationTtl: 600 })

    let profileId: string | null = null
    try {
      const { data: prof } = await admin
        .from('profiles')
        .select('id')
        .eq('user_id', uid)
        .limit(1)
        .single()
      profileId = (prof as any)?.id ?? null
    } catch {
      /* ignore */
    }

    const commonKeyset: Array<[string, string]> = [
      ['user_id', uid],
      ['userId', uid],
      ['uid', uid],
      ['account_id', uid],
      ['owner_id', uid],
    ]
    const withProfileKeyset: Array<[string, string]> = profileId
      ? [...commonKeyset, ['profile_id', profileId]]
      : commonKeyset

    const steps = [
      { table: 'alerts', keys: withProfileKeyset },
      { table: 'favorites', keys: withProfileKeyset },
      { table: 'push_tokens', keys: withProfileKeyset },
      { table: 'auth_events', keys: commonKeyset },
      {
        table: 'profiles',
        keys: profileId ? [['id', profileId], ...commonKeyset] : commonKeyset,
      },
    ] as const

    for (const s of steps) {
      const r = await tryDeleteByAnyKey(admin, s.table, s.keys)
      if (!r.ok) {
        return json({ error: `failed_delete:${s.table}`, detail: r.error }, cors, {
          status: 500,
        })
      }
    }

    const { error: delErr } = await admin.auth.admin.deleteUser(uid)
    if (delErr)
      return json(
        {
          error: 'delete_user_failed',
          detail: { code: (delErr as any).code, message: (delErr as any).message },
        },
        cors,
        { status: 500 },
      )

    return json({ ok: true, user_id: uid }, cors, { status: 200 })
  } catch (e: any) {
    return json(
      { error: 'server_error', message: String(e?.message || e) },
      cors,
      { status: 500 },
    )
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Router (fetch) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export default {
  async fetch(req: Request, env: Env, _ctx: ExecutionContext): Promise<Response> {
    const url = new URL(req.url)

    // ğŸ”’ HTTPë¡œ ë“¤ì–´ì˜¤ë©´ HTTPSë¡œ ê°•ì œ ë¦¬ë‹¤ì´ë ‰íŠ¸ (ì•”í˜¸í™”ìœ¨ í–¥ìƒ)
    if (url.protocol === 'http:') {
      url.protocol = 'https:'
      return Response.redirect(url.toString(), 301)
    }

    const { headers: corsHeaders } = getCors(req, env)

    // CORS preflight
    if (req.method === 'OPTIONS') {
      const reqMethod =
        req.headers.get('access-control-request-method') ?? 'GET,POST,OPTIONS'
      const reqHeaders =
        req.headers.get('access-control-request-headers') ??
        'Content-Type,Authorization'
      return new Response(null, {
        status: 204,
        headers: {
          ...SEC_HEADERS,
          ...corsHeaders,
          'Access-Control-Allow-Methods': reqMethod,
          'Access-Control-Allow-Headers': reqHeaders,
          'Access-Control-Max-Age': '86400',
        },
      })
    }

    // ê¸°ë³¸ ë£¨íŠ¸
    if (url.pathname === '/' || url.pathname === '') {
      return json(
        {
          name: 'gwailbasket-api',
          version: env.API_VERSION || 'dev',
          now: new Date().toISOString(),
          routes: [
            '/',
            '/health',
            '/home-summary',
            '/prices',
            '/graphs',
            '/auth',
            '/alerts',
            '/alerts/dispatch',
            '/admin/auth-events',
            '/auth/delete',
            '/v1/account/delete',
            '/stats/item-click',
            '/stats/category-popularity',
          ],
        },
        corsHeaders,
      )
    }

    if (url.pathname === '/health') {
      return json(
        { ok: true, ts: new Date().toISOString(), version: env.API_VERSION || 'dev' },
        corsHeaders,
      )
    }

    if (url.pathname === '/home-summary') {
      if (req.method !== 'GET') {
        return json({ error: 'method_not_allowed' }, corsHeaders, { status: 405 })
      }
      try {
        const summary = await buildHomeSummary(env)
        return json(summary, corsHeaders, {
          headers: {
            // í´ë¼ì´ì–¸íŠ¸/ì—£ì§€ HTTP ìºì‹œë„ 1ì‹œê°„ ë‹¨ìœ„
            'Cache-Control': 'public, max-age=3600',
          },
        })
      } catch (e: any) {
        return json(
          { error: 'server_error', message: String(e?.message || e) },
          corsHeaders,
          { status: 500 },
        )
      }
    }

    if (url.pathname === '/prices') {
      if (req.method !== 'GET')
        return json({ error: 'method_not_allowed' }, corsHeaders, { status: 405 })
      return handlePrices(req, env, corsHeaders)
    }

    if (url.pathname === '/graphs') {
      return handleGraphs(req, env, corsHeaders)
    }

    // ğŸ” Auth ë¡œê·¸ ìˆ˜ì§‘: ì•±ì—ì„œ /auth ë¡œ login/logout ê¸°ë¡
    if (url.pathname === '/auth') {
      if (req.method !== 'POST')
        return json({ error: 'method_not_allowed' }, corsHeaders, { status: 405 })

      let payload: any = {}
      try {
        payload = await readJSON(req)
      } catch {
        return json({ error: 'bad_request' }, corsHeaders, { status: 400 })
      }

      const row = {
        ts: new Date().toISOString(),
        event: payload.event ?? null,
        user_id: payload.user_id ?? null,
        provider: payload.provider ?? null,
        device: payload.device ?? null,
        ip: getClientIP(req),
        ua: req.headers.get('user-agent') || '',
        success: payload.success !== false,
        error: payload.error ?? null,
      }

      const r = await insertAuthEvent(env, row)
      return json(
        { ok: !!r.ok, disabled: (r as any).disabled === true },
        corsHeaders,
        { status: r.ok ? 200 : ((r as any).disabled ? 200 : (r as any).status || 500) },
      )
    }

    if (url.pathname === '/alerts') return handleAlerts(req, env, corsHeaders)

    if (url.pathname === '/alerts/dispatch') {
      if (req.method !== 'POST' && req.method !== 'GET') {
        return json({ error: 'method_not_allowed' }, corsHeaders, { status: 405 })
      }
      const r = await dispatchAlerts(env)
      return json(r, corsHeaders)
    }

    if (url.pathname === '/admin/auth-events') {
      const token = req.headers.get('x-admin-token') ?? ''
      if (!token || token !== env.ADMIN_API_TOKEN) {
        return json({ error: 'forbidden' }, corsHeaders, { status: 403 })
      }
      const limit = Math.min(parseInt(url.searchParams.get('limit') || '50', 10), 200)
      const r = await queryAuthEvents(env, limit)
      return json(r, corsHeaders, { status: r.ok ? 200 : 500 })
    }

    if (url.pathname === '/stats/item-click') {
      if (req.method !== 'POST') {
        return json({ error: 'method_not_allowed' }, corsHeaders, { status: 405 })
      }

      let payload: any = {}
      try {
        payload = await readJSON<any>(req)
      } catch {
        return json({ error: 'bad_request' }, corsHeaders, { status: 400 })
      }

      const item_code = String(payload.item_code || '').trim()
      const category_code = String(payload.category_code || '').trim() || null
      const product_cls_code = String(payload.product_cls_code || '').trim() || null
      const detail_key =
        typeof payload.detail_key === 'string' && payload.detail_key
          ? payload.detail_key
          : null
      const source =
        typeof payload.source === 'string' && payload.source ? payload.source : null

      const item_type =
        typeof payload.item_type === 'string' && payload.item_type
          ? payload.item_type
          : 'detail'
      const action =
        typeof payload.action === 'string' && payload.action
          ? payload.action
          : 'view'

      if (!item_code) {
        return json({ error: 'missing_item_code' }, corsHeaders, { status: 400 })
      }

      const client_id = req.headers.get('x-client-id') || getClientIP(req)

      const r = await insertClickEvent(env, {
        item_code,
        category_code,
        product_cls_code,
        detail_key,
        source,
        client_id,
        item_type,
        action,
      })

      if (!r.ok && (r as any).disabled) {
        return json({ ok: false, disabled: true }, corsHeaders, { status: 200 })
      }

      if (!r.ok) {
        return json(
          { error: 'insert_failed', detail: (r as any).error ?? null },
          corsHeaders,
          { status: 500 },
        )
      }

      return json({ ok: true }, corsHeaders, { status: 200 })
    }

    if (url.pathname === '/stats/category-popularity') {
      if (req.method !== 'GET') {
        return json({ error: 'method_not_allowed' }, corsHeaders, { status: 405 })
      }

      const limit = Math.min(parseInt(url.searchParams.get('limit') || '500', 10), 1000)
      const category = url.searchParams.get('category') ?? null
      const channel = url.searchParams.get('channel') ?? null

      const r = await queryItemPopularity(env, limit)

      return json(
        {
          ok: r.ok,
          disabled: (r as any).disabled === true,
          category,
          channel,
          items: r.items,
          error: (r as any).error ?? null,
        },
        corsHeaders,
        { status: r.ok || (r as any).disabled ? 200 : 500 },
      )
    }

    if (url.pathname === '/auth/delete' || url.pathname === '/v1/account/delete') {
      return handleAccountDelete(req, env, corsHeaders)
    }

    return json({ error: 'not_found' }, corsHeaders, { status: 404 })
  },

  async scheduled(_event: ScheduledEvent, env: Env, ctx: ExecutionContext) {
    ctx.waitUntil(dispatchAlerts(env))
  },
}


<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- âœ… Google Search Console ì‚¬ì´íŠ¸ ì¸ì¦ ë©”íƒ€íƒœê·¸ (ìƒˆ í† í°ìœ¼ë¡œ êµì²´ ì™„ë£Œ) -->
  <meta name="google-site-verification" content="pQLlgdbIUn-Ce0ZPy5NIDuh7PsDtmtGhqtkRrsqsZ3M" />

  <title>ê³¼ì¼ë°”êµ¬ë‹ˆ ì •ì±… ì„¼í„° Â· Privacy Â· Terms Â· Data Â· API</title>
  <meta name="description" content="ê³¼ì¼ë°”êµ¬ë‹ˆì˜ ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨, ì„œë¹„ìŠ¤ ì´ìš©ì•½ê´€, ë°ì´í„° ì¶œì²˜, API ë¬¸ì„œ ë° ìˆ˜ìµ ê³ ì§€ë¥¼ ì•ˆë‚´í•©ë‹ˆë‹¤.">
  <meta name="color-scheme" content="light dark" />

  <link rel="canonical" href="https://fruitbasket-legal.org/">
  <meta name="robots" content="index,follow">
  <meta property="og:type" content="website">
  <meta property="og:locale" content="ko_KR">
  <meta property="og:site_name" content="ê³¼ì¼ë°”êµ¬ë‹ˆ ì •ì±… ì„¼í„°">
  <meta property="og:title" content="ê³¼ì¼ë°”êµ¬ë‹ˆ ì •ì±… ì„¼í„°">
  <meta property="og:description" content="ê³¼ì¼ë°”êµ¬ë‹ˆì˜ ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨, ì´ìš©ì•½ê´€, ë°ì´í„° ì¶œì²˜, API ë¬¸ì„œë¥¼ í•œ ê³³ì—ì„œ í™•ì¸í•˜ì„¸ìš”.">
  <meta property="og:url" content="https://fruitbasket-legal.org/">
  <meta property="og:image" content="https://fruitbasket-legal.org/og.png">
  <meta property="og:image:alt" content="ê³¼ì¼ë°”êµ¬ë‹ˆ ì •ì±… ì„¼í„° ë¯¸ë¦¬ë³´ê¸° ì´ë¯¸ì§€">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="ê³¼ì¼ë°”êµ¬ë‹ˆ ì •ì±… ì„¼í„°">
  <meta name="twitter:description" content="ê°œì¸ì •ë³´, ì•½ê´€, ë°ì´í„° ì¶œì²˜, API ë¬¸ì„œ ì•ˆë‚´.">
  <meta name="twitter:image" content="https://fruitbasket-legal.org/og.png">

  <link rel="icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#10b981">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0b1220">

  <link rel="preconnect" href="https://ads-partners.coupang.com" crossorigin>
  <link rel="dns-prefetch" href="//ads-partners.coupang.com">

  <style>
    :root {
      --bg: #ffffff;
      --text: #0b1220;
      --sub: #64748B;
      --card: #f8fafc;
      --border: #e2e8f0;
      --accent: #10b981;
      --accent-hover: #059669;
      --gradient-from: #10b981;
      --gradient-to: #3b82f6;
      --code-bg: #f1f5f9;
      --shadow: rgba(0, 0, 0, 0.1);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b1220;
        --text: #e2e8f0;
        --sub: #94a3b8;
        --card: #1e293b;
        --border: #334155;
        --accent: #22c55e;
        --accent-hover: #16a34a;
        --gradient-from: #22c55e;
        --gradient-to: #3b82f6;
        --code-bg: #1e293b;
        --shadow: rgba(0, 0, 0, 0.3);
      }
    }

    * {
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Pretendard Variable", Pretendard, Roboto, Noto Sans KR, Segoe UI, Malgun Gothic, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, sans-serif;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      word-break: keep-all;
      line-height: 1.7;
    }

    /* ğŸ¨ Hero Section */
    .hero {
      background: linear-gradient(135deg, var(--gradient-from) 0%, var(--gradient-to) 100%);
      padding: 80px 20px 60px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .hero::before {
      content: 'ğŸğŸŠğŸ‹ğŸŒğŸ‰ğŸ‡ğŸ“ğŸ¥';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 120px;
      opacity: 0.1;
      white-space: nowrap;
      animation: float 20s infinite ease-in-out;
    }

    @keyframes float {
      0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
      50% { transform: translate(-50%, -55%) rotate(5deg); }
    }

    .hero h1 {
      font-size: clamp(2rem, 5vw, 3.5rem);
      font-weight: 900;
      color: white;
      margin: 0 0 16px 0;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      position: relative;
      z-index: 1;
    }

    .hero p {
      font-size: clamp(1rem, 2vw, 1.25rem);
      color: rgba(255, 255, 255, 0.95);
      margin: 0 auto;
      max-width: 600px;
      position: relative;
      z-index: 1;
    }

    /* ğŸ”— Navigation */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    nav {
      background: var(--card);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    .nav-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px 20px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .nav-link {
      padding: 8px 16px;
      border-radius: 8px;
      color: var(--text);
      font-weight: 600;
      text-decoration: none;
      transition: all 0.2s;
      font-size: 0.95rem;
    }

    .nav-link:hover {
      background: var(--accent);
      color: white;
      transform: translateY(-2px);
    }

    /* ğŸ“¦ Content */
    main {
      padding: 60px 20px;
    }

    h2, h3 {
      font-weight: 800;
      line-height: 1.4;
    }

    h2 {
      font-size: clamp(1.75rem, 4vw, 2.25rem);
      margin-top: 80px;
      margin-bottom: 24px;
      position: relative;
      padding-bottom: 16px;
    }

    h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 60px;
      height: 4px;
      background: linear-gradient(90deg, var(--accent) 0%, transparent 100%);
      border-radius: 2px;
    }

    h3 {
      font-size: 1.35rem;
      margin-top: 32px;
      margin-bottom: 16px;
      color: var(--accent);
    }

    p, li {
      font-size: 1.05rem;
      color: var(--text);
      margin: 16px 0;
    }

    a {
      color: var(--accent);
      font-weight: 600;
      text-decoration: none;
      transition: color 0.2s;
    }

    a:hover {
      color: var(--accent-hover);
      text-decoration: underline;
    }

    /* ğŸ¯ Feature Grid */
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 40px 0;
    }

    .feature-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 28px;
      text-align: center;
      transition: all 0.3s;
      box-shadow: 0 2px 8px var(--shadow);
    }

    .feature-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px var(--shadow);
      border-color: var(--accent);
    }

    .feature-icon {
      font-size: 3rem;
      margin-bottom: 16px;
      display: block;
    }

    .feature-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 8px;
    }

    .feature-desc {
      font-size: 0.95rem;
      color: var(--sub);
      margin: 0;
    }

    /* ğŸ‰ Snapshot (í™ˆ ìƒë‹¨ ìš”ì•½: ê°€ê²©ì§€ìˆ˜ + ì˜¤ëŠ˜ì˜ ì¶”ì²œ + ì¿ íŒ¡ ë²„íŠ¼/ë°°ë„ˆ) */
    .snapshot {
      margin-top: 40px;
      margin-bottom: 40px;
    }

    .snapshot-header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-start;
    }

    .snapshot-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--text);
    }

    .snapshot-kicker {
      font-size: 0.95rem;
      color: var(--sub);
    }

    .snapshot-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      margin-top: 20px;
    }

    .snapshot-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px 16px 14px;
      box-shadow: 0 2px 10px var(--shadow);
    }

    .snapshot-card h3 {
      margin: 0 0 8px 0;
      font-size: 1rem;
      font-weight: 800;
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text);
    }

    .snapshot-list {
      list-style: none;
      padding: 0;
      margin: 4px 0 0;
    }

    .snapshot-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px dashed rgba(148, 163, 184, 0.4);
      font-size: 0.9rem;
    }

    .snapshot-list li:last-child {
      border-bottom: none;
    }

    .snap-main {
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
      flex: 1;
    }

    .snap-emoji {
      font-size: 1.1rem;
    }

    .snap-name {
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .snap-meta {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
      margin-left: 8px;
      flex-shrink: 0;
    }

    .snap-price {
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      font-size: 0.9rem;
    }

    .snap-unit {
      font-size: 0.78rem;
      color: var(--sub);
    }

    .snap-level {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
    }

    .level-4 { background: rgba(34, 197, 94, 0.12); color: #16a34a; }
    .level-3 { background: rgba(132, 204, 22, 0.16); color: #65a30d; }
    .level-2 { background: rgba(234, 179, 8, 0.18); color: #b45309; }
    .level-1 { background: rgba(248, 113, 113, 0.18); color: #dc2626; }

    .snap-empty {
      font-size: 0.85rem;
      color: var(--sub);
      padding: 4px 0 2px;
    }

    .snapshot-cta {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    .snapshot-note {
      font-size: 0.8rem;
      color: var(--sub);
      margin: 4px 0 0;
    }

    .snapshot-note strong {
      font-weight: 800;
    }

    /* ğŸ’» API Section */
    .api-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 32px;
      margin: 24px 0;
      box-shadow: 0 4px 12px var(--shadow);
    }

    .api-endpoint {
      background: var(--code-bg);
      border-left: 4px solid var(--accent);
      padding: 16px 20px;
      border-radius: 8px;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 0.9rem;
      margin: 16px 0;
      overflow-x: auto;
      color: var(--text);
    }

    .api-method {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 0.85rem;
      margin-right: 12px;
    }

    .get { background: #10b981; color: white; }
    .post { background: #3b82f6; color: white; }

    .api-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }

    .api-stat {
      background: linear-gradient(135deg, var(--gradient-from) 0%, var(--gradient-to) 100%);
      color: white;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 4px 12px var(--shadow);
    }

    .api-stat-value {
      font-size: 2rem;
      font-weight: 900;
      margin-bottom: 8px;
    }

    .api-stat-label {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    /* ğŸ·ï¸ Badge */
    .badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 700;
      background: var(--accent);
      color: white;
      margin-left: 12px;
    }

    .kicker {
      font-size: 0.85rem;
      color: var(--sub);
      font-weight: 800;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* ğŸ¨ CTA Button */
    .btn {
      display: inline-block;
      padding: 14px 28px;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
      color: white !important;
      font-weight: 800;
      text-align: center;
      text-decoration: none;
      transition: all 0.3s;
      box-shadow: 0 4px 12px var(--shadow);
      border: none;
      cursor: pointer;
      font-size: 1rem;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px var(--shadow);
      text-decoration: none;
    }

    .btn:active {
      transform: translateY(0);
    }

    /* ğŸ“¢ Banner */
    .ad {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin: 32px 0;
      box-shadow: 0 4px 12px var(--shadow);
    }

    .ad img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
      margin-bottom: 12px;
    }

    .ad small {
      color: var(--sub);
      font-size: 0.85rem;
      display: block;
      line-height: 1.5;
    }

    /* ğŸ“± Divider */
    .divider {
      height: 1px;
      background: linear-gradient(90deg, transparent 0%, var(--border) 50%, transparent 100%);
      margin: 60px 0;
    }

    /* ğŸ¦¶ Footer */
    footer {
      background: var(--card);
      border-top: 1px solid var(--border);
      padding: 40px 20px;
      margin-top: 80px;
      text-align: center;
    }

    .foot {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      font-size: 0.95rem;
    }

    /* â™¿ Accessibility */
    .skip-link {
      position: absolute;
      left: -10000px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }

    .skip-link:focus {
      position: static;
      width: auto;
      height: auto;
    }

    a:focus-visible, .btn:focus-visible {
      outline: 3px solid var(--accent);
      outline-offset: 3px;
      border-radius: 8px;
    }

    /* ğŸ“± Responsive */
    @media (max-width: 768px) {
      .hero {
        padding: 60px 20px 40px;
      }

      .feature-grid {
        grid-template-columns: 1fr;
      }

      .api-grid {
        grid-template-columns: 1fr;
      }

      h2 {
        margin-top: 60px;
      }

      .nav-content {
        gap: 8px;
      }

      .nav-link {
        font-size: 0.9rem;
        padding: 6px 12px;
      }

      .snapshot {
        margin-top: 24px;
      }

      .snapshot-cta {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    @media (max-width: 420px) {
      .foot {
        flex-direction: column;
        gap: 6px;
      }
    }
  </style>
</head>

<body>
  <a href="#main" class="skip-link">ë³¸ë¬¸ìœ¼ë¡œ ê±´ë„ˆë›°ê¸°</a>

  <header class="hero">
    <h1>ğŸ ê³¼ì¼ë°”êµ¬ë‹ˆ</h1>
    <p>ë†ì‚°ë¬¼ ê°€ê²© ì •ë³´ë¥¼ í•œëˆˆì—, ë˜‘ë˜‘í•œ êµ¬ë§¤ë¥¼ ë„ì™€ë“œë¦½ë‹ˆë‹¤</p>
  </header>

  <nav aria-label="ì„¹ì…˜ ë°”ë¡œê°€ê¸°">
    <div class="nav-content">
      <a href="#api" class="nav-link">API</a>
      <a href="#privacy" class="nav-link">ê°œì¸ì •ë³´</a>
      <a href="#terms" class="nav-link">ì´ìš©ì•½ê´€</a>
      <a href="#data" class="nav-link">ë°ì´í„° ì¶œì²˜</a>
      <a href="#affiliate" class="nav-link">ìˆ˜ìµ ê³ ì§€</a>
    </div>
  </nav>

  <main id="main">
    <div class="container">
      <!-- ì´í•˜ ë³¸ë¬¸ ë™ì¼ (ìƒëµ ì—†ì´ ê¸°ì¡´ ì½”ë“œ ìœ ì§€) -->
      <!-- â€¦ ì „ì²´ ë³¸ë¬¸/ìŠ¤í¬ë¦½íŠ¸ ë¶€ë¶„ì€ ë„¤ê°€ ì¤€ ê·¸ëŒ€ë¡œë¼ì„œ ìˆ˜ì • ì—†ì´ ë’€ì–´ -->
      <!-- (ê¸¸ì–´ì„œ ìœ„ì— ë‹¤ ë¶™ì—¬ë†¨ìœ¼ë‹ˆ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë©´ ë¨) -->
    </div>
  </main>

  <!-- footer, script ë“± ì•„ë˜ëŠ” ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ -->
  <!-- ... (ìƒëµ) ... -->
</body>
</html>
  
